use ade;
select * from ade_schema.student

--constraints -- column level rules 
--primary key , unique key, check, null key, not null, default, foriegn key

--pk- unique + not null 
--uk - allows one null + unique 
--not null - allows duplicates but not nulls
--check -- (age>18)
--default -('def')


drop table t1
create table t1(id int primary key , 
name varchar(50) unique, age int check(age>18), status varchar(50) default('absent'))

insert into t1(id, name, age) values(1, 'abc',19)
select * from t1


---------------------------------------------------------------------------------------------------------
--create, constrints, updates, deletes
---------------------------------------------------------------------------------------------------------
--dql

select * from t1
select id from t1
----------------------------------------------------------------------------------------------------------
--merge -insert, update, delete
--scd ( slowly changing dimensions)
--t1(source) - t2(target)
--(id,name) - t2(id,name)
--(1,'abc') - (1,abc) --current 
--(1,'def')-- -  (1,def)  --name change


--scd type 1: overwrites previous records 
--replaces previous value with current value
--drawback -- doesnt preserve history 

--scd type 2: preserves historical data by adding a new row
--(1,'abc') - (1,abc, flag- true(current))-(historical), expire date)
--condition - if source.id in target.id 
--new row insertion - (1,def, true)
--update - provious flag value to false

--scd type 3: preserves hostory by adding a column
--t1(source) - t2(target)
--(id,name) - t2(id,name)
--(1,'abc') - (1,abc) 

--(id,name, new_name)
--(1,abc,'def')
--only two 

select * from ProductSales
delete from dim_products where productid = 101
select productid, region from productsales where saleid = 4
select * from dim_products
CREATE TABLE dim_products ( --target table
    productid INT,
    region VARCHAR(50),
    effective_date DATE,
    expiry_date DATE,
    is_current CHAR(1) --flag
);

--scd type 1
MERGE dim_products AS target
USING (SELECT DISTINCT productid,region FROM productsales where saleid = 4 ) AS source
    ON target.productid = source.productid -- common column 
WHEN MATCHED AND target.region <> source.region  THEN 
    UPDATE SET target.region = source.region
WHEN NOT MATCHED  THEN
    INSERT (productid, region, effective_date, expiry_date, is_current)
    VALUES (source.productid, source.region, GETDATE(), NULL, 'Y');

	--scd type2
MERGE dim_products AS target
USING (SELECT DISTINCT productid, region FROM productsales where saleid =11  ) AS source
    ON target.productid = source.productid
   AND target.is_current = 'Y'
WHEN MATCHED AND target.region <> source.region THEN
    UPDATE SET target.expiry_date = GETDATE(),
               target.is_current = 'N'
WHEN NOT MATCHED BY target THEN
    INSERT (productid, region, effective_date, expiry_date, is_current)
    VALUES (source.productid, source.region, GETDATE(), NULL, 'Y');

select * from dim_products
select * from productsales 






--select -- selects columns  
--* -- all columns 
--from -- table name 

--query -- group of clauses 
--clause -- group by, distinct, having, orderby, join, top, limit...........
--query writing order -- select - *,col--from --join--where--group by-having -- orderby -- select 

use practicedb;
select saleid,productid from ProductSales -- optimized
select * from productsales -- 1m -20 

--

--where clause --filtering --some part of table , subset 
/* where clause with single colum
select * from productsales where {col = 'value'
                                  col > value
								  col < value
								  col >= value
								  col <= value
								  } */
--read records which are from north region 
select * from ProductSales where region = 'north'
select * from productsales where quantity > 3
select * from productsales where quantity < 3
select * from productsales where quantity >= 3
select * from productsales where quantity <= 3

--where with multiple columns 
/*
select * from productsales where col1 = value and col2 = value
                                 col1 = value or col2 = value
*/
--fetch records having region = north and quantity > 3 

select * from productsales where region = 'north' and quantity > 3 --or productname = 'laptop';
select * from productsales where productname = 'laptop';
-----------------------------------------------------------------------------------------------------------------
/*
between , in
select * from productsales where col1 between value1 and value2 
select * from productsales where col1 in (value1, value2)
*/

select * from ProductSales
--fetch records where quantity between 3 and 10
select * from productsales where quantity >= 3 and quantity <=10;
select * from productsales where quantity between 3 and 10;

--fetch records of productname in laptop or mobile 
select * from productsales where productname in ('laptop','mobile')
select * from productsales where productname = 'laptop' or productname = 'mobile'
---------------------------------------------------------------------------------------------------------
/*
select * from product;
filtering null values
*/                             
select * from product where unitprice is null; -- to find null values within column
select * from product where unitprice is not null; -- to find non ull values within column
---------------------------------------------------------------------------------------------------------
--like operator(%)

select * from ProductSales

select * from ProductSales where productname like 'H%' -- starting value
select * from productsales where productname like '%a%' -- middle value
select * from productsales where productname like '%e' -- end value
select * from productsales where productname like 'L%P'

--wildcrad character(_)
select * from productsales where productname like 'L___p'
-----------------------------------------------------------------------------------------------------------
--from -- addressess table 
----------------------------------------------------------------------------------------------------------
--group by
/*
aggregations -- sum, avg, min, max, count
select sum(unitprice) as t_unitprice from productsales;
derived column -- sum(unitprice)
as - aliasing
select avg(unitprice) as t_avg from productsales;
select max(unitprice) as m_unitprice from productsales;
select min(unitprice) as min_unitprice from productsales;
select count(*) as count_records from productsales; -- table count 
select count(1) as count from productsales;

usecase:
to find aggregations on top of grouped data
--to know number of duplicates
--group by will have only unique records

syntax:
select grouping column(option), aggregation(col) from table group by grouping column;

to find duplicates:
select col1,col2,col3, count(*) from tablr group by col1,colk2,col3;
*/

--fetch totalunitprice for each product(aggregation + foreach)

select productname, sum(unitprice) as total_unitprice from productsales group by productname
-----------------------------------------------------------------------------------------------------------

select productid,productname from ProductSales
--to find duplicates 
select productid,productname,count(*) as t_count from productsales group by productid,productname;

--distinct(gives unique records non-duplicates)

select distinct productid,productname from ProductSales
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
--low cordinality column , high cordinality column
----------------------------------------------------------------------------------------------------------------

--having clause
--to filter aggregated records
-----------------------------------------------------------------------------------------------------------------
select productid,productname,count(*) as t_count from productsales where saleid between 1 and 10 group by productid,productname having count(*) >=1;

--execution order 
--from --where--groupby-having

-----------------------------------------------------------------------------------------------------------------------------------------------------
--order by clause
--usecase - sorting 
--select * from table order by col1 asc/desc
--select * from table order by col1 asc/desc, col2 asc/desc, col3 asc/desc...

select * from productsales order by saleid desc;
select * from productsales order by saleid desc, ProductID asc;
--from-order by-select 


select top 2 productid,productname,count(*) as t_count from productsales where saleid between 1 and 10 group by productid,productname having count(*) >=1 order by count(*) desc, productname desc;

--execution order
--from-where-groupby-having-orderby-select 
-----------------------------------------------------------------------------------------------------------------------

--to list top 10 rows 
--top 
select top 10 * from productsales order by totalamount desc 
--limit/offset fetchnext
select * from productsales order by totalamount desc offset 5 rows fetch next 5 rows only; 
--------------------------------------------------------------------------------------------------------------------------
--derived columns 
--derives from original columns

select *,(0.5 * totalamount) as discountamount from productsales

--iif, case when 
--conditional derived columns
--iif-- iff(expression, true condition, false condition)-- if--else
select *, iif(productname = 'Laptop', (0.5 * totalamount),(0.4*totalamount)) as discountamount from productsales

--case when --if-elif-ladder

select *, case 
when productname = 'laptop' and region = 'North' then (0.5 * totalamount) 
when productname = 'tablet' then (0.4 * totalamount)
else 0
end as distountamount
from productsales

---find sum(totalamount) for product laptop
select productname, sum(case when productname = 'laptop' then (0.5 * totalamount) else totalamount end) as t_amount from productsales group by productname 

--group by - case when
select * from productsales;
select case when productname in('laptop', 'tablet') then 'valid' else 'invalid' end as newcol, count(*) as count from productsales
group by case when productname in('laptop', 'tablet') then 'valid' else 'invalid' end
-----------------------------------------------------------------------------------------------------------------------------------
--joins -- to combine two or more tables
--types - left, right, inner, full outer join, cross join
--common column
--inner - fetch matched records from both tables
--left - fetches all records from left table and matched records from right table 
--right- fetches all records from right table table and matched records from left table
--full- inner+left+right
--cross - product of number of records from left table and right table 

--syntax
--select * from table1 {join} table 2 on table1.col = table2.col

select * from t2
select * from t3

select t3.col1, t2.* from t3 left join t2 on t2.col2 = t3.col2 

insert into t2(col1) values (3)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Merge
------------------------------------------------------------------------------------------------------------------------------------------------------------------
--merge -insert, update, delete
--scd ( slowly changing dimensions)
--t1(source) - t2(target)
--(id,name) - t2(id,name)
--(1,'abc') - (1,abc) --current 
--(1,'def')-- -  (1,def)  --name change

--scd type 1: overwrites previous records 
--replaces previous value with current value
--drawback -- doesnt preserve history 

--scd type 2: preserves historical data by adding a new row
--(1,'abc') - (1,abc, flag- true(current))-(historical), expire date)
--condition - if source.id in target.id 
--new row insertion - (1,def, true)
--update - provious flag value to false

--scd type 3: preserves hostory by adding a column
--t1(source) - t2(target)
--(id,name) - t2(id,name)
--(1,'abc') - (1,abc) 

--(id,name, new_name)
--(1,abc,'def')
--only two 

select * from ProductSales
delete from dim_products where productid = 101
select productid, region from productsales where saleid = 4
select * from dim_products
CREATE TABLE dim_products ( --target table
    productid INT,
    region VARCHAR(50),
    effective_date DATE,
    expiry_date DATE,
    is_current CHAR(1) --flag
);

--scd type 1
MERGE dim_products AS target
USING (SELECT DISTINCT productid,region FROM productsales where saleid = 4 ) AS source
    ON target.productid = source.productid -- common column 
WHEN MATCHED AND target.region <> source.region  THEN 
    UPDATE SET target.region = source.region
WHEN NOT MATCHED  THEN
    INSERT (productid, region, effective_date, expiry_date, is_current)
    VALUES (source.productid, source.region, GETDATE(), NULL, 'Y');

	--scd type2
MERGE dim_products AS target
USING (SELECT DISTINCT productid, region FROM productsales where saleid =11  ) AS source
    ON target.productid = source.productid
   AND target.is_current = 'Y'
WHEN MATCHED AND target.region <> source.region THEN
    UPDATE SET target.expiry_date = GETDATE(),
               target.is_current = 'N'
WHEN NOT MATCHED BY target THEN
    INSERT (productid, region, effective_date, expiry_date, is_current)
    VALUES (source.productid, source.region, GETDATE(), NULL, 'Y');

select * from dim_products
select * from productsales 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
date functions
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
--date functions
----------------------------------------------------------------------------------------
select * from productsales;
--to get current date
select getdate()
--year(saledate)-- extracts year from date, month(saledate) - extracts month, day(saledate) - extracts date
select saledate,year(saledate) as year, month(saledate) as month, day(saledate) as day from ProductSales

--dateadd- preavious or future date travelling
select saledate,dateadd(month,-1, saledate) as previous_month from productsales
select saledate,dateadd(day,-720, saledate) as previous_month from productsales
select saledate,dateadd(year,-1, saledate) as previous_month from productsales

--datediff -- two get date difference
select saledate, datediff(year, saledate, getdate()) from productsales

--emonth -- to get last day of month
select EOMONTH('2025-02-14') as last_day_of_month from productsales

--datepart
select getdate(), datepart(year, getdate()) as year,
datepart(month,getdate()) as month, 
datepart(day,getdate()) as day,
datepart(quarter,getdate()) as quarter,
datepart(hour, getdate()) as hour,
datepart(minute,getdate()) as min,
datepart(second,getdate()) as seconds

select DATEFROMPARTS(2021,11,20)

SELECT CONVERT(DATETIME, '2025-09-04', 23) AS ConvertedDate;
SELECT CONVERT(DATETIME, '09/04/2025', 101) AS USDate;
SELECT CONVERT(DATETIME, '04/09/2025', 103) AS UKDate;

--datename
select datename(day,'2025-09-01') --- 4 - thursday

------------------------------------------------------------------------------------------------------------------------------------------------------------------

--view - create view vw_1 as (query)
--subquery - query inside
--cte - with ctename as (query)

--temptables 
--local temptable(#),global temptable(##)
--select * into global_temp_table from productsales

--select * from global_temp_table

--window functions
--ranking function - rank, row number, dense rank
--aggregation with over clause
--lead,lag

--select totalamount, row_number() over(order by totalamount desc) as rank from productsales
--duplicates
select distinct totalamount from productsales -- unique records 

--duplicated rows count
select totalamount, count(*) from productsales group by totalamount

--to fetch duplicated records
select totalamount, row_number() over(partition by totalamount order by totalamount desc) as rank1 from productsales;

with mycte as (
select *, row_number() over(partition by totalamount order by totalamount desc) as rank1 from #produt_temp_table
)
delete from mycte where rank1 > 1

select * from #produt_temp_table


--rank
select *, rank() over( partition by region order by totalamount desc) as rank1 from productsales;

--dense_rank()
select *, dense_rank() over( partition by region order by totalamount desc) as rank1 from productsales;
--note: orderby is mandatory
----------------------------------------------------------------------------------------------------------------------------------------------
--fetch top highest revenued product

--step_1- select *, dense_rank() over(order by totalamount desc) as highest_revenue_rank from productsales
--with highest_revenued_product as (
select *, dense_rank() over(order by totalamount desc) as highest_revenue_rank from productsales)
select * from highest_revenued_product where highest_revenue_rank in(1,2,3)

--fetch top highest revenued product for each region
with highest_revenued_product as (
select *, dense_rank() over(partition by region order by totalamount desc) as highest_revenue_rank from productsales)
select * from highest_revenued_product where highest_revenue_rank in(1)
----------------------------------------------------------------------------------------------------------------------------------------------------

--Find the 2nd highest transaction per user without using LIMIT or TOP
--userid,transactionAmount
--with mycte as (select *, dense_rank() over(partition by userid order transactAmaount desc) as rank from trnsactiontable)
--select * from mycte where rank = 2
-------------------------------------------------------------------------------------------------------------------------------------------------

--aggregations with over clause
select * from productsales

select sum(totalamount) from productsales
select productname, sum(totalamount) from productsales group by productname
----------------------------------------------------------------------------------------------------------------------------------------------------
select *, sum(totalamount) over() as total_sum from productsales
select *, sum(totalamount) over(partition by productname) from productsales
-------------------------------------------------------------------------------------------------------------------------------------------------
--rolling sum/cumulative sum (sum() with over(order by)
------------------------------------------------------------------------------------------------------------------------------------------------
select *, sum(totalamount) over(partition by productname order by totalamount desc) as cumsum from productsales
-------------------------------------------------------------------------------------------------------------------------------------------------
Sample table:
CREATE TABLE ProductSales (
    ProductID INT,
    ProductName VARCHAR(100),
    SaleDate DATE,
    Quantity INT,
    UnitPrice DECIMAL(10,2),
    TotalAmount AS (Quantity * UnitPrice) PERSISTED, -- computed column
    CustomerID INT
);

INSERT INTO ProductSales (ProductID, ProductName, SaleDate, Quantity, UnitPrice, CustomerID)
VALUES
(1, 'Laptop',       '2024-01-05', 2, 800.00, 101),
(2, 'Smartphone',   '2024-01-06', 1, 600.00, 102),
(3, 'Tablet',       '2024-01-07', 3, 300.00, 103),
(4, 'Headphones',   '2024-01-08', 5, 50.00, 104),
(5, 'Monitor',      '2024-01-09', 2, 200.00, 105),
(6, 'Keyboard',     '2024-01-10', 4, 40.00, 106),
(7, 'Mouse',        '2024-01-11', 6, 25.00, 107),
(8, 'Printer',      '2024-01-12', 1, 150.00, 108),
(9, 'Camera',       '2024-01-13', 2, 500.00, 109),
(10,'Speaker',      '2024-01-14', 3, 75.00, 110),
(11,'Smartwatch',   '2024-01-15', 2, 250.00, 111),
(12,'External HDD', '2024-01-16', 4, 120.00, 112),
(13,'Router',       '2024-01-17', 2, 90.00, 113),
(14,'Projector',    '2024-01-18', 1, 450.00, 114),
(15,'Webcam',       '2024-01-19', 5, 60.00, 115),
(16,'Microphone',   '2024-01-20', 2, 110.00, 116),
(17,'Drone',        '2024-01-21', 1, 900.00, 117),
(18,'Game Console', '2024-01-22', 2, 500.00, 118),
(19,'Charger',      '2024-01-23', 6, 30.00, 119),
(20,'TV',           '2024-01-24', 1, 1200.00, 120);
------------------------------------------------------------------------------------------------------------------------------------------------------------------










